package main

// sliceは長さと容量を持つ, length, capacity
// capacityはsliceの最初の要素から数えて元となる配列の要素数

import "fmt"

func printSlice(s []int) {
	fmt.Printf("ken=%d cap=%d %v\n", len(s), cap(s), s)
}



// s = s[...] の操作では元の配列は残っている
// ただし、sからはアクセスできる範囲が変わるだけ
// 他に参照がなければ、GCが回収する
// func main () {
// 	s := []int{2,3,6,7,11,13}
//     printSlice(s)

// 	fmt.Println("--- Slice the slice to give it zero length --")
// 	s = s[:0]
// 	printSlice(s)
	
// 	fmt.Println("--- Extend its length. --")
// 	s = s[:4]
// 	printSlice(s)
	
// 	fmt.Println("--- Drop its first two values. --")
// 	s = s[2:]
// 	printSlice(s)
// }



// 【元の配列】
// インデックス: 0   1   2   3   4   5
// 配列の中身:  [2,  3,  6,  7, 11, 13]


// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ① s := []int{2,3,6,7,11,13}
//    len=6, cap=6, [2 3 6 7 11 13]

// 配列: [2,  3,  6,  7, 11, 13]
//        ↑________________________
//        |ポインタ (開始位置)      |
//        |←------- len=6 ------→|
//        |←------- cap=6 ------→|


// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ② s = s[:0]
//    len=0, cap=6, []

// 配列: [2,  3,  6,  7, 11, 13]
//        ↑
//        |ポインタ (位置そのまま)
//        (len=0 表示なし)
//        |←------- cap=6 ------→|
//        ※ポインタは動いてないのでcap=6


// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ③ s = s[:4]
//    len=4, cap=6, [2 3 6 7]

// 配列: [2,  3,  6,  7, 11, 13]
//        ↑___________________
//        |ポインタ (位置そのまま)
//        |←- len=4 -→|
//        |←------- cap=6 ------→|
//        ※先頭から切るのでcap=6のまま


// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// ④ s = s[2:]
//    len=2, cap=4, [6 7]

// 配列: [2,  3,  6,  7, 11, 13]
//       (捨) (捨)  ↑___________
//                  |ポインタが右に2つ移動！
//                  |← len=2 →|
//                  |←-- cap=4 --→|
//                  ※インデックス2→5の4要素

// Nil slices
// スライスのゼロ値はnil
// nilスライスは0の長さと容量を持っており、元となる配列を持っていない


func main() {
	var s []int
	fmt.Println(s, len(s), cap(s))
	if s == nil {
		fmt.Println("nil!")
	}
}